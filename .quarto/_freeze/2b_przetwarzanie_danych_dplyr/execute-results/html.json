{
  "hash": "1862529f26b582a9ed8b601bea15c89c",
  "result": {
    "markdown": "# Przetwarzanie danych - dplyr\n\n\n\n\n\n## Pakiety\n\n### Pakiet dplyr\n\nPakiet `dplyr` wykorzystuje się do podstawowych operacji przetwarzania danych z wykrzystaniem obiektów typu data.frame. Podstawowe funkcje pakietu to:\n\n-   `select()` - tworzenie podzbioru danych poprzez wybór zmiennych na podstawie ich nazw,\n-   `filter()` - tworzenie podzbioru danych poprzez wybór wierszy na podstawie określonego warunku,\n-   `arrange()` - sortowanie danych,\n-   `mutate()` - tworzenie nowych zmiennych na podstawie określenia warunku,\n-   `summarize()` - podsumowanie danych, np. poprzez obliczenie statystyk podstawowych.\n\nPakiet `dplyr` dostarcza także funkcji:\n\n-   do grupowania danych: `group_by()` - pozwala na wykonanie operacji w podziale na grupy.\n-   do łączenia dwóch lub więcej obiektów (data.frame): `join()`, `left_join()`, `right_join()`\n\nPakiet `dplyr` pozwala także na wykorzystanie operatora łączącego funkcje %\\>%\n\nWięcej informacji:\n\n-   dokumentacja pakietu: <https://dplyr.tidyverse.org/>\n-   podstawowe funkcje pakietu: [\"Cheat Sheet\"](https://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf)\n\n### Pakiet tidyr\n\nDane wykorzysywane w analizach muszą być przechowywane w tzw. uporządkowany sposób (ang. *tidy data*). Uporządkowane dane to dane, w których:\n\n-   każda zmienna przechowywana jest w osobnej kolumnie.\n-   każda obserwacja jest zapisana w osobnym wierszu w tabeli danych\n-   każda wartość przechowywana jest w osobnej komórce (tzn. każda komórka przechowuje tylko jedną wartość).\n\nPakiet `tidyr()` zawiera zestaw funkcji, które ułatwiają tworzenie uporządkowanych danych. Uporządkowane dane mogą być przechowywane w dwóch układach: układzie długim i układzie szerokim (więcej informacji w podrozdziale @sec-uklad-danych)\n\nWięcej informacji:\n\n-   dokumentacja: <https://tidyr.tidyverse.org/>\\\n-   cheat sheet: <https://github.com/rstudio/cheatsheets/blob/main/tidyr.pdf>\n\n\n\n\n\n## Przetwarzanie danych z pakietem `dplyr`\n\n### Funkcja `select()`\n\n-   **Wybór kolumn *country*, *year* oraz *pop*.**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsel1 <- select(gapminder, country, year, pop)\nhead(sel1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 3\n  country      year      pop\n  <fct>       <int>    <int>\n1 Afghanistan  1952  8425333\n2 Afghanistan  1957  9240934\n3 Afghanistan  1962 10267083\n4 Afghanistan  1967 11537966\n5 Afghanistan  1972 13079460\n6 Afghanistan  1977 14880372\n```\n:::\n:::\n\n\n> Ze zbioru danych gapminder proszę wybrać dane dla zmiennych country, year oraz lifeExp.\n\n-   **Wybór wszystkich kolumn z wyjątkiem kolumny *kontynent***\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsel2 <- select(gapminder, -continent)\nhead(sel2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 5\n  country      year lifeExp      pop gdpPercap\n  <fct>       <int>   <dbl>    <int>     <dbl>\n1 Afghanistan  1952    28.8  8425333      779.\n2 Afghanistan  1957    30.3  9240934      821.\n3 Afghanistan  1962    32.0 10267083      853.\n4 Afghanistan  1967    34.0 11537966      836.\n5 Afghanistan  1972    36.1 13079460      740.\n6 Afghanistan  1977    38.4 14880372      786.\n```\n:::\n:::\n\n\n> Ze zbioru danych gapminder proszę wybrać wszystkie kolumny z wyjątkiem continent oraz gdpPercap.\n\n### Funkcja `filter()`\n\nFunkcja `filter()` służy do tworzenia podzbiorów danych poprzez wybór obserwacji spełniających określone warunki. Warunki są określane za pomocą operatorów logicznych (!=, ==, \\>, \\<, \\>=, \\<=, \\|, &).\n\n-   **Wybór danych dla roku 2007.**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilt1 <- filter(gapminder, year == 2007)\nhead(filt1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 6\n  country     continent  year lifeExp      pop gdpPercap\n  <fct>       <fct>     <int>   <dbl>    <int>     <dbl>\n1 Afghanistan Asia       2007    43.8 31889923      975.\n2 Albania     Europe     2007    76.4  3600523     5937.\n3 Algeria     Africa     2007    72.3 33333216     6223.\n4 Angola      Africa     2007    42.7 12420476     4797.\n5 Argentina   Americas   2007    75.3 40301927    12779.\n6 Australia   Oceania    2007    81.2 20434176    34435.\n```\n:::\n:::\n\n\n> Wybierz dane dla kontynentu Europa.\n\n> W jaki inny sposób można wybrać dane dla roku 2007?\n\n-   **Wybór danych dla roku 2007, w których oczekiwana długość trwania życia przekracza 80 lat.**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilt2 <- filter(gapminder, year == 2007 & lifeExp > 80)\nfilt2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 13 × 6\n   country          continent  year lifeExp       pop gdpPercap\n   <fct>            <fct>     <int>   <dbl>     <int>     <dbl>\n 1 Australia        Oceania    2007    81.2  20434176    34435.\n 2 Canada           Americas   2007    80.7  33390141    36319.\n 3 France           Europe     2007    80.7  61083916    30470.\n 4 Hong Kong, China Asia       2007    82.2   6980412    39725.\n 5 Iceland          Europe     2007    81.8    301931    36181.\n 6 Israel           Asia       2007    80.7   6426679    25523.\n 7 Italy            Europe     2007    80.5  58147733    28570.\n 8 Japan            Asia       2007    82.6 127467972    31656.\n 9 New Zealand      Oceania    2007    80.2   4115771    25185.\n10 Norway           Europe     2007    80.2   4627926    49357.\n11 Spain            Europe     2007    80.9  40448191    28821.\n12 Sweden           Europe     2007    80.9   9031088    33860.\n13 Switzerland      Europe     2007    81.7   7554661    37506.\n```\n:::\n:::\n\n\n> Wybór danych dla roku 2007, dla wszystkich kontynentów z wyjątkiem Azji, w których oczekiwana długość trwania życia przekracza 80 lat.\n\n### Funkcja `mutate()`\n\nFunkcja `mutate()` służy do tworzenia nowych zmiennych na podstawie określonego wyrażenia\n\n-   **Dodaj kolumnę *abbr_country* zawierającą trzyliterowy kod państwa.**\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngap2 <- mutate(gapminder, abbr_country = toupper(substr(country, 1, 3)))\nhead(gap2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 7\n  country     continent  year lifeExp      pop gdpPercap abbr_country\n  <fct>       <fct>     <int>   <dbl>    <int>     <dbl> <chr>       \n1 Afghanistan Asia       1952    28.8  8425333      779. AFG         \n2 Afghanistan Asia       1957    30.3  9240934      821. AFG         \n3 Afghanistan Asia       1962    32.0 10267083      853. AFG         \n4 Afghanistan Asia       1967    34.0 11537966      836. AFG         \n5 Afghanistan Asia       1972    36.1 13079460      740. AFG         \n6 Afghanistan Asia       1977    38.4 14880372      786. AFG         \n```\n:::\n:::\n\n\n> Co w powyższym poleceniu robi funkcja `substr()` oraz `toupper()`?\n\n> Dodaj do zbioru danych kolumnę pop_mln zawierająca liczbę ludności w milionach.\n\n### Funkcja `arrange()`\n\nFunkcja `arrange()` wykorzystywana jest do sortowania danych.\n\n-   **Sortowanie rosnące względem zmiennej *lifeExp***\n\n\n::: {.cell}\n\n```{.r .cell-code}\narr1 <- arrange(gapminder, lifeExp)\nhead(arr1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 6\n  country      continent  year lifeExp     pop gdpPercap\n  <fct>        <fct>     <int>   <dbl>   <int>     <dbl>\n1 Rwanda       Africa     1992    23.6 7290203      737.\n2 Afghanistan  Asia       1952    28.8 8425333      779.\n3 Gambia       Africa     1952    30    284320      485.\n4 Angola       Africa     1952    30.0 4232095     3521.\n5 Sierra Leone Africa     1952    30.3 2143249      880.\n6 Afghanistan  Asia       1957    30.3 9240934      821.\n```\n:::\n:::\n\n\n-   **Sortowanie malejące względem zmiennej *lifeExp***\n\n\n::: {.cell}\n\n```{.r .cell-code}\narr2 <- arrange(gapminder, desc(lifeExp))\nhead(arr2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 6\n  country          continent  year lifeExp       pop gdpPercap\n  <fct>            <fct>     <int>   <dbl>     <int>     <dbl>\n1 Japan            Asia       2007    82.6 127467972    31656.\n2 Hong Kong, China Asia       2007    82.2   6980412    39725.\n3 Japan            Asia       2002    82   127065841    28605.\n4 Iceland          Europe     2007    81.8    301931    36181.\n5 Switzerland      Europe     2007    81.7   7554661    37506.\n6 Hong Kong, China Asia       2002    81.5   6762476    30209.\n```\n:::\n:::\n\n\n> Posortuj dane malejąco względem zmiennej pop.\n\n-   **Sortowanie rosnące względem kontynentu (*continent*) oraz oczekiwanej długości trwania życia (*lifeExp*)**\n\n\n::: {.cell}\n\n```{.r .cell-code}\narr3 <- arrange(gapminder, continent, lifeExp)\nhead(arr3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 6\n  country      continent  year lifeExp     pop gdpPercap\n  <fct>        <fct>     <int>   <dbl>   <int>     <dbl>\n1 Rwanda       Africa     1992    23.6 7290203      737.\n2 Gambia       Africa     1952    30    284320      485.\n3 Angola       Africa     1952    30.0 4232095     3521.\n4 Sierra Leone Africa     1952    30.3 2143249      880.\n5 Mozambique   Africa     1952    31.3 6446316      469.\n6 Sierra Leone Africa     1957    31.6 2295678     1004.\n```\n:::\n:::\n\n\n> Posortuj malejąco względem nazwy państwa oraz rosnąco względem liczby ludności.\n\n### Funkcja `rename()`\n\nFunkcja `rename()` służy do zmiany nazw kolumn. W funkcji `rename()` definiujemy *nowa_nazwa = stara_nazwa*.\n\n-   **Zmiana nazw kolumn na polskie nazwy.**\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngap2 <- rename(gapminder, panstwo = country, kontynent = continent, rok = year, dlugosc_zycia = lifeExp, ludnosc = pop, PKB = gdpPercap)\nnames(gap2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"panstwo\"       \"kontynent\"     \"rok\"           \"dlugosc_zycia\"\n[5] \"ludnosc\"       \"PKB\"          \n```\n:::\n:::\n\n\n> Korzystając ze strony pomocy funkcji `rename()` sprawdź jak w zmienić nazwy kolumn w obiekcie gap2 na drukowane litery.\n\n### Funkcja `summarize()`\n\nFunkcja `summarize()` służy do wykonywania podsumowań statystycznych. Tworzy kolumny z zadanymi statystykami.\n\n-   **Średnia oczekiwana długość trwania życia.**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsmr1 <- summarize(gapminder, \n          srednia = mean(lifeExp))\nsmr1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 1\n  srednia\n    <dbl>\n1    59.5\n```\n:::\n:::\n\n\n-   **Średnia, minimalna oraz maksymalna oczekiwana długość trwania życia.**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsmr2 <- summarize(gapminder, \n          srednia = mean(lifeExp),\n          min = min(lifeExp),\n          max = max(lifeExp))\nsmr2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 3\n  srednia   min   max\n    <dbl> <dbl> <dbl>\n1    59.5  23.6  82.6\n```\n:::\n:::\n\n\n> Oblicz średnią, odchylenie standardowe, minimum i maksimum dla zmiennej gdpPercap. \n\n### Grupowanie .by\n\n-   argument .by; np. summarize(, .by) - grupowanie dokonywane tylko na potrzeby danej funkcji\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrp1 = summarize(filt1 ,\n                 srednia = mean(lifeExp), \n                 .by = continent)\ngrp1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 2\n  continent srednia\n  <fct>       <dbl>\n1 Asia         70.7\n2 Europe       77.6\n3 Africa       54.8\n4 Americas     73.6\n5 Oceania      80.7\n```\n:::\n:::\n\n\n> Oblicz minimalną i maksymalną długość trwania życia w 2007 roku w podziale na kontynenty.\n\n### Funkcja `pull()`\n\nFunkcja `pull()` służy do wyciągania tylko jednej zmiennej\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlife_exp <- pull(gapminder, lifeExp)\nhead(life_exp)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 28.801 30.332 31.997 34.020 36.088 38.438\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncontinent <- pull(gapminder, continent)\nhead(continent)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] Asia Asia Asia Asia Asia Asia\nLevels: Africa Americas Asia Europe Oceania\n```\n:::\n:::\n\n\n> Wybierz ze zbioru danych kolumnę pop.\n\n### Operator łączący (`%>%`).\n\nUżywając pakietu `dplyr` można łączyć ze sobą funkcje używając operatora `%>%`\n\n#### Przykład\n\nKtóre kraje w roku 1952 miały liczbę ludności powyżej 100 milionów?\n\nAby odpowiedzieć na to pytanie możemy wykonać każdą operację osobno, i jej wynik zapisać w osobnym obiekcie. Operator łączący `%>%` pozwala natomiast na przekazanie wyniku działania jednej funkcji do drugiej, bez tworzenia osobnych obiektów.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf1 <- filter(gapminder, pop > 100000000 & year == 1952)\ns1 <- select(f1, country, pop)\na1 <- arrange(s1, pop) # sortowanie danych wzgledem pop\na1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 2\n  country             pop\n  <fct>             <int>\n1 United States 157553000\n2 India         372000000\n3 China         556263527\n```\n:::\n:::\n\n\n-   **Wykorzystanie operatora łączącego `%>%`**\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- gapminder %>%  #wejsciowy zbior danych\n  filter(pop > 100000000 & year == 1952) %>% # wybor krajow z pop > 100mln w roku 1952\n  select(country, pop) %>% # wybor kolumn country, pop \n  arrange(pop) # sortowanie danych wzgledem pop\n\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 2\n  country             pop\n  <fct>             <int>\n1 United States 157553000\n2 India         372000000\n3 China         556263527\n```\n:::\n:::\n\n\n> Które kraje w 2007 roku miały populację powyżej 100 milionów? Posortuj wynik od krajów z największą liczbą ludności do krajów z najmniejszą liczbą ludności.\n\n### Funkcja `join()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- data.frame(country = c(\"Poland\", \"USA\", \"Germany\"), pop = c(36.82, 333.3, 83.8))\n\ny = data.frame(country = c(\"Poland\", \"USA\", \"Italy\"), pop = c(36.82, 333.3, 58.94))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  country    pop\n1  Poland  36.82\n2     USA 333.30\n3 Germany  83.80\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  country    pop\n1  Poland  36.82\n2     USA 333.30\n3   Italy  58.94\n```\n:::\n:::\n\n\n-   Funkcja `inner_join(x, y)` zwraca tylko obiekty występujące w obu tabelach\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninner_df <- inner_join(x, y, by = 'country')\ninner_df \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  country  pop.x  pop.y\n1  Poland  36.82  36.82\n2     USA 333.30 333.30\n```\n:::\n:::\n\n\n-   Funkcja `left_join(x, y)` zachowuje wszystkie obserwacje w x, niezależnie od tego, czy mają swój odpowiednik w tabeli y. Jest to najczęściej używane łączenie, ponieważ gwarantuje, że nie utracimy obserwacji z tabeli podstawowej (x).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nleft_df <- left_join(x, y, by = 'country')\nleft_df\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  country  pop.x  pop.y\n1  Poland  36.82  36.82\n2     USA 333.30 333.30\n3 Germany  83.80     NA\n```\n:::\n:::\n\n\n-   Funkcja `right_join(x, y)` zachowuje wszystkie obserwacje w y.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nright_df <- right_join(x, y, by = 'country')\nright_df\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  country  pop.x  pop.y\n1  Poland  36.82  36.82\n2     USA 333.30 333.30\n3   Italy     NA  58.94\n```\n:::\n:::\n\n\n-   Funkcja `full_join(x, y)` zwraca wszystkie obiekty z tabeli x oraz z tabeli y.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfull_df <- full_join(x, y, by = 'country')\nfull_df\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  country  pop.x  pop.y\n1  Poland  36.82  36.82\n2     USA 333.30 333.30\n3 Germany  83.80     NA\n4   Italy     NA  58.94\n```\n:::\n:::\n\n\n## Układ danych {#sec-uklad-danych}\n\nDane w tabeli mogą być zapisywane w układzie **długim** lub **szerokim**.\n\n![Układ danych (po lewej) - szeroki; (po prawej) długi](figures/2_wide_long.png)\n\nZmiana układu danych jest możliwa z użyciem funkcji z pakietu `tidyr`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyr)\n```\n:::\n\n\n-   **Układ długi**\n\nDane gapminder są zapisane w układzie długim:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(gapminder, 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 × 6\n   country     continent  year lifeExp      pop gdpPercap\n   <fct>       <fct>     <int>   <dbl>    <int>     <dbl>\n 1 Afghanistan Asia       1952    28.8  8425333      779.\n 2 Afghanistan Asia       1957    30.3  9240934      821.\n 3 Afghanistan Asia       1962    32.0 10267083      853.\n 4 Afghanistan Asia       1967    34.0 11537966      836.\n 5 Afghanistan Asia       1972    36.1 13079460      740.\n 6 Afghanistan Asia       1977    38.4 14880372      786.\n 7 Afghanistan Asia       1982    39.9 12881816      978.\n 8 Afghanistan Asia       1987    40.8 13867957      852.\n 9 Afghanistan Asia       1992    41.7 16317921      649.\n10 Afghanistan Asia       1997    41.8 22227415      635.\n```\n:::\n:::\n\n\n-   **Układ szeroki**\n\nFunkcja `pivot_wider()` przekształca dane z formatu długiego w szeroki. Obiekt gapminder_wide w każdej kolumnie przechowuje dane dla jednego roku, a w każdym wierszu dla kraju.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder2 <- select(gapminder, -continent, \n                    -lifeExp, -gdpPercap)\ngapminder_wide <- pivot_wider(gapminder2, \n                             names_from = year, \n                             values_from = pop)\n\nhead(gapminder_wide)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 13\n  country  `1952` `1957` `1962` `1967` `1972` `1977` `1982` `1987` `1992` `1997`\n  <fct>     <int>  <int>  <int>  <int>  <int>  <int>  <int>  <int>  <int>  <int>\n1 Afghani… 8.43e6 9.24e6 1.03e7 1.15e7 1.31e7 1.49e7 1.29e7 1.39e7 1.63e7 2.22e7\n2 Albania  1.28e6 1.48e6 1.73e6 1.98e6 2.26e6 2.51e6 2.78e6 3.08e6 3.33e6 3.43e6\n3 Algeria  9.28e6 1.03e7 1.10e7 1.28e7 1.48e7 1.72e7 2.00e7 2.33e7 2.63e7 2.91e7\n4 Angola   4.23e6 4.56e6 4.83e6 5.25e6 5.89e6 6.16e6 7.02e6 7.87e6 8.74e6 9.88e6\n5 Argenti… 1.79e7 1.96e7 2.13e7 2.29e7 2.48e7 2.70e7 2.93e7 3.16e7 3.40e7 3.62e7\n6 Austral… 8.69e6 9.71e6 1.08e7 1.19e7 1.32e7 1.41e7 1.52e7 1.63e7 1.75e7 1.86e7\n# ℹ 2 more variables: `2002` <int>, `2007` <int>\n```\n:::\n:::\n\n\n> Wybierz z danych kolumnę lifeExp oraz year i zamień dane na układ szeroki. \n\n-   **Układ szeroki -\\> Układ długi**\n\n\n\n\n\n> Wybierz z danych kolumnę gdpPercap oraz year i zamień dane na układ szeroki. Następnie z układu szerokiego zamień dane na układ długi.  ",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}